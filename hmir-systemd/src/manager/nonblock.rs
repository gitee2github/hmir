// This code was autogenerated with `dbus-codegen-rust `, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::nonblock;

pub trait OrgFreedesktopDBusPeer {
    fn ping(&self) -> nonblock::MethodReply<()>;
    fn get_machine_id(&self) -> nonblock::MethodReply<String>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusPeer for nonblock::Proxy<'a, C> {

    fn ping(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.DBus.Peer", "Ping", ())
    }

    fn get_machine_id(&self) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.DBus.Peer", "GetMachineId", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> nonblock::MethodReply<String>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusIntrospectable for nonblock::Proxy<'a, C> {

    fn introspect(&self) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.DBus.Introspectable", "Introspect", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }
}

pub trait OrgFreedesktopDBusProperties {
    fn get(&self, interface_name: &str, property_name: &str) -> nonblock::MethodReply<arg::Variant<Box<dyn arg::RefArg + 'static>>>;
    fn get_all(&self, interface_name: &str) -> nonblock::MethodReply<arg::PropMap>;
    fn set(&self, interface_name: &str, property_name: &str, value: arg::Variant<Box<dyn arg::RefArg>>) -> nonblock::MethodReply<()>;
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusProperties for nonblock::Proxy<'a, C> {

    fn get(&self, interface_name: &str, property_name: &str) -> nonblock::MethodReply<arg::Variant<Box<dyn arg::RefArg + 'static>>> {
        self.method_call("org.freedesktop.DBus.Properties", "Get", (interface_name, property_name, ))
            .and_then(|r: (arg::Variant<Box<dyn arg::RefArg + 'static>>, )| Ok(r.0, ))
    }

    fn get_all(&self, interface_name: &str) -> nonblock::MethodReply<arg::PropMap> {
        self.method_call("org.freedesktop.DBus.Properties", "GetAll", (interface_name, ))
            .and_then(|r: (arg::PropMap, )| Ok(r.0, ))
    }

    fn set(&self, interface_name: &str, property_name: &str, value: arg::Variant<Box<dyn arg::RefArg>>) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.DBus.Properties", "Set", (interface_name, property_name, value, ))
    }
}

pub trait OrgFreedesktopSystemd1Manager {
    fn get_unit(&self, name: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn get_unit_by_pid(&self, pid: u32) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn get_unit_by_invocation_id(&self, invocation_id: Vec<u8>) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn get_unit_by_control_group(&self, cgroup: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn load_unit(&self, name: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn start_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn start_unit_with_flags(&self, name: &str, mode: &str, flags: u64) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn start_unit_replace(&self, old_unit: &str, new_unit: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn stop_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn reload_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn restart_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn try_restart_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn reload_or_restart_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn reload_or_try_restart_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn enqueue_unit_job(&self, name: &str, job_type: &str, job_mode: &str) -> nonblock::MethodReply<(u32, dbus::Path<'static>, String, dbus::Path<'static>, String, Vec<(u32, dbus::Path<'static>, String, dbus::Path<'static>, String)>)>;
    fn kill_unit(&self, name: &str, whom: &str, signal: i32) -> nonblock::MethodReply<()>;
    fn clean_unit(&self, name: &str, mask: Vec<&str>) -> nonblock::MethodReply<()>;
    fn freeze_unit(&self, name: &str) -> nonblock::MethodReply<()>;
    fn thaw_unit(&self, name: &str) -> nonblock::MethodReply<()>;
    fn reset_failed_unit(&self, name: &str) -> nonblock::MethodReply<()>;
    fn set_unit_properties(&self, name: &str, runtime: bool, properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>) -> nonblock::MethodReply<()>;
    fn bind_mount_unit(&self, name: &str, source: &str, destination: &str, read_only: bool, mkdir: bool) -> nonblock::MethodReply<()>;
    fn mount_image_unit(&self, name: &str, source: &str, destination: &str, read_only: bool, mkdir: bool, options: Vec<(&str, &str)>) -> nonblock::MethodReply<()>;
    fn ref_unit(&self, name: &str) -> nonblock::MethodReply<()>;
    fn unref_unit(&self, name: &str) -> nonblock::MethodReply<()>;
    fn start_transient_unit(&self, name: &str, mode: &str, properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>, aux: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)>) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn get_unit_processes(&self, name: &str) -> nonblock::MethodReply<Vec<(String, u32, String)>>;
    fn attach_processes_to_unit(&self, unit_name: &str, subcgroup: &str, pids: Vec<u32>) -> nonblock::MethodReply<()>;
    fn abandon_scope(&self, name: &str) -> nonblock::MethodReply<()>;
    fn get_job(&self, id: u32) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn get_job_after(&self, id: u32) -> nonblock::MethodReply<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>>;
    fn get_job_before(&self, id: u32) -> nonblock::MethodReply<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>>;
    fn cancel_job(&self, id: u32) -> nonblock::MethodReply<()>;
    fn clear_jobs(&self) -> nonblock::MethodReply<()>;
    fn reset_failed(&self) -> nonblock::MethodReply<()>;
    fn set_show_status_(&self, mode: &str) -> nonblock::MethodReply<()>;
    fn list_units(&self) -> nonblock::MethodReply<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>>;
    fn list_units_filtered(&self, states: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>>;
    fn list_units_by_patterns(&self, states: Vec<&str>, patterns: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>>;
    fn list_units_by_names(&self, names: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>>;
    fn list_jobs(&self) -> nonblock::MethodReply<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>>;
    fn subscribe(&self) -> nonblock::MethodReply<()>;
    fn unsubscribe(&self) -> nonblock::MethodReply<()>;
    fn dump(&self) -> nonblock::MethodReply<String>;
    fn dump_by_file_descriptor(&self) -> nonblock::MethodReply<arg::OwnedFd>;
    fn reload(&self) -> nonblock::MethodReply<()>;
    fn reexecute(&self) -> nonblock::MethodReply<()>;
    fn exit(&self) -> nonblock::MethodReply<()>;
    fn reboot(&self) -> nonblock::MethodReply<()>;
    fn power_off(&self) -> nonblock::MethodReply<()>;
    fn halt(&self) -> nonblock::MethodReply<()>;
    fn kexec(&self) -> nonblock::MethodReply<()>;
    fn switch_root(&self, new_root: &str, init: &str) -> nonblock::MethodReply<()>;
    fn set_environment_(&self, assignments: Vec<&str>) -> nonblock::MethodReply<()>;
    fn unset_environment(&self, names: Vec<&str>) -> nonblock::MethodReply<()>;
    fn unset_and_set_environment(&self, names: Vec<&str>, assignments: Vec<&str>) -> nonblock::MethodReply<()>;
    fn enqueue_marked_jobs(&self) -> nonblock::MethodReply<Vec<dbus::Path<'static>>>;
    fn list_unit_files(&self) -> nonblock::MethodReply<Vec<(String, String)>>;
    fn list_unit_files_by_patterns(&self, states: Vec<&str>, patterns: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String)>>;
    fn get_unit_file_state(&self, file: &str) -> nonblock::MethodReply<String>;
    fn enable_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)>;
    fn disable_unit_files(&self, files: Vec<&str>, runtime: bool) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn enable_unit_files_with_flags(&self, files: Vec<&str>, flags: u64) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)>;
    fn disable_unit_files_with_flags(&self, files: Vec<&str>, flags: u64) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn reenable_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)>;
    fn link_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn preset_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)>;
    fn preset_unit_files_with_mode(&self, files: Vec<&str>, mode: &str, runtime: bool, force: bool) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)>;
    fn mask_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn unmask_unit_files(&self, files: Vec<&str>, runtime: bool) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn revert_unit_files(&self, files: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn set_default_target(&self, name: &str, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn get_default_target(&self) -> nonblock::MethodReply<String>;
    fn preset_all_unit_files(&self, mode: &str, runtime: bool, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn add_dependency_unit_files(&self, files: Vec<&str>, target: &str, type_: &str, runtime: bool, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>>;
    fn get_unit_file_links(&self, name: &str, runtime: bool) -> nonblock::MethodReply<Vec<String>>;
    fn set_exit_code_(&self, number: u8) -> nonblock::MethodReply<()>;
    fn lookup_dynamic_user_by_name(&self, name: &str) -> nonblock::MethodReply<u32>;
    fn lookup_dynamic_user_by_uid(&self, uid: u32) -> nonblock::MethodReply<String>;
    fn get_dynamic_users(&self) -> nonblock::MethodReply<Vec<(u32, String)>>;
    fn version(&self) -> nonblock::MethodReply<String>;
    fn features(&self) -> nonblock::MethodReply<String>;
    fn virtualization(&self) -> nonblock::MethodReply<String>;
    fn architecture(&self) -> nonblock::MethodReply<String>;
    fn tainted(&self) -> nonblock::MethodReply<String>;
    fn firmware_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn firmware_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn loader_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn loader_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn kernel_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn kernel_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn init_rdtimestamp(&self) -> nonblock::MethodReply<u64>;
    fn init_rdtimestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn userspace_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn userspace_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn finish_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn security_start_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn security_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn security_finish_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn security_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn generators_start_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn generators_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn generators_finish_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn generators_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn units_load_start_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn units_load_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn units_load_finish_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn units_load_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn units_load_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn units_load_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn init_rdsecurity_start_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn init_rdsecurity_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn init_rdsecurity_finish_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn init_rdsecurity_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn init_rdgenerators_start_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn init_rdgenerators_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn init_rdgenerators_finish_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn init_rdgenerators_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn init_rdunits_load_start_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn init_rdunits_load_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn init_rdunits_load_finish_timestamp(&self) -> nonblock::MethodReply<u64>;
    fn init_rdunits_load_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64>;
    fn log_level(&self) -> nonblock::MethodReply<String>;
    fn set_log_level(&self, value: String) -> nonblock::MethodReply<()>;
    fn log_target(&self) -> nonblock::MethodReply<String>;
    fn set_log_target(&self, value: String) -> nonblock::MethodReply<()>;
    fn nnames(&self) -> nonblock::MethodReply<u32>;
    fn nfailed_units(&self) -> nonblock::MethodReply<u32>;
    fn njobs(&self) -> nonblock::MethodReply<u32>;
    fn ninstalled_jobs(&self) -> nonblock::MethodReply<u32>;
    fn nfailed_jobs(&self) -> nonblock::MethodReply<u32>;
    fn progress(&self) -> nonblock::MethodReply<f64>;
    fn environment(&self) -> nonblock::MethodReply<Vec<String>>;
    fn confirm_spawn(&self) -> nonblock::MethodReply<bool>;
    fn show_status(&self) -> nonblock::MethodReply<bool>;
    fn unit_path(&self) -> nonblock::MethodReply<Vec<String>>;
    fn default_standard_output(&self) -> nonblock::MethodReply<String>;
    fn default_standard_error(&self) -> nonblock::MethodReply<String>;
    fn runtime_watchdog_usec(&self) -> nonblock::MethodReply<u64>;
    fn set_runtime_watchdog_usec(&self, value: u64) -> nonblock::MethodReply<()>;
    fn runtime_watchdog_pre_usec(&self) -> nonblock::MethodReply<u64>;
    fn set_runtime_watchdog_pre_usec(&self, value: u64) -> nonblock::MethodReply<()>;
    fn runtime_watchdog_pre_governor(&self) -> nonblock::MethodReply<String>;
    fn set_runtime_watchdog_pre_governor(&self, value: String) -> nonblock::MethodReply<()>;
    fn reboot_watchdog_usec(&self) -> nonblock::MethodReply<u64>;
    fn set_reboot_watchdog_usec(&self, value: u64) -> nonblock::MethodReply<()>;
    fn kexec_watchdog_usec(&self) -> nonblock::MethodReply<u64>;
    fn set_kexec_watchdog_usec(&self, value: u64) -> nonblock::MethodReply<()>;
    fn service_watchdogs(&self) -> nonblock::MethodReply<bool>;
    fn set_service_watchdogs(&self, value: bool) -> nonblock::MethodReply<()>;
    fn control_group(&self) -> nonblock::MethodReply<String>;
    fn system_state(&self) -> nonblock::MethodReply<String>;
    fn exit_code(&self) -> nonblock::MethodReply<u8>;
    fn default_timer_accuracy_usec(&self) -> nonblock::MethodReply<u64>;
    fn default_timeout_start_usec(&self) -> nonblock::MethodReply<u64>;
    fn default_timeout_stop_usec(&self) -> nonblock::MethodReply<u64>;
    fn default_timeout_abort_usec(&self) -> nonblock::MethodReply<u64>;
    fn default_restart_usec(&self) -> nonblock::MethodReply<u64>;
    fn default_start_limit_interval_usec(&self) -> nonblock::MethodReply<u64>;
    fn default_start_limit_burst(&self) -> nonblock::MethodReply<u32>;
    fn default_cpuaccounting(&self) -> nonblock::MethodReply<bool>;
    fn default_block_ioaccounting(&self) -> nonblock::MethodReply<bool>;
    fn default_memory_accounting(&self) -> nonblock::MethodReply<bool>;
    fn default_tasks_accounting(&self) -> nonblock::MethodReply<bool>;
    fn default_limit_cpu(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_cpusoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_fsize(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_fsizesoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_data(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_datasoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_stack(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_stacksoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_core(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_coresoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_rss(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_rsssoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_nofile(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_nofilesoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_as(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_assoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_nproc(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_nprocsoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_memlock(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_memlocksoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_locks(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_lockssoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_sigpending(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_sigpendingsoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_msgqueue(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_msgqueuesoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_nice(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_nicesoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_rtprio(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_rtpriosoft(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_rttime(&self) -> nonblock::MethodReply<u64>;
    fn default_limit_rttimesoft(&self) -> nonblock::MethodReply<u64>;
    fn default_tasks_max(&self) -> nonblock::MethodReply<u64>;
    fn timer_slack_nsec(&self) -> nonblock::MethodReply<u64>;
    fn default_oompolicy(&self) -> nonblock::MethodReply<String>;
    fn default_oomscore_adjust(&self) -> nonblock::MethodReply<i32>;
    fn ctrl_alt_del_burst_action(&self) -> nonblock::MethodReply<String>;
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitNew {
    pub id: String,
    pub unit: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.unit, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitNew {
            id: i.read()?,
            unit: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitNew {
    const NAME: &'static str = "UnitNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitRemoved {
    pub id: String,
    pub unit: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.unit, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitRemoved {
            id: i.read()?,
            unit: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitRemoved {
    const NAME: &'static str = "UnitRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerJobNew {
    pub id: u32,
    pub job: dbus::Path<'static>,
    pub unit: String,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerJobNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.job, i);
        arg::RefArg::append(&self.unit, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerJobNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerJobNew {
            id: i.read()?,
            job: i.read()?,
            unit: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerJobNew {
    const NAME: &'static str = "JobNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerJobRemoved {
    pub id: u32,
    pub job: dbus::Path<'static>,
    pub unit: String,
    pub result: String,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerJobRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.job, i);
        arg::RefArg::append(&self.unit, i);
        arg::RefArg::append(&self.result, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerJobRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerJobRemoved {
            id: i.read()?,
            job: i.read()?,
            unit: i.read()?,
            result: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerJobRemoved {
    const NAME: &'static str = "JobRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerStartupFinished {
    pub firmware: u64,
    pub loader: u64,
    pub kernel: u64,
    pub initrd: u64,
    pub userspace: u64,
    pub total: u64,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerStartupFinished {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.firmware, i);
        arg::RefArg::append(&self.loader, i);
        arg::RefArg::append(&self.kernel, i);
        arg::RefArg::append(&self.initrd, i);
        arg::RefArg::append(&self.userspace, i);
        arg::RefArg::append(&self.total, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerStartupFinished {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerStartupFinished {
            firmware: i.read()?,
            loader: i.read()?,
            kernel: i.read()?,
            initrd: i.read()?,
            userspace: i.read()?,
            total: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerStartupFinished {
    const NAME: &'static str = "StartupFinished";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitFilesChanged {
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitFilesChanged {
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    const NAME: &'static str = "UnitFilesChanged";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerReloading {
    pub active: bool,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerReloading {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.active, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerReloading {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerReloading {
            active: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerReloading {
    const NAME: &'static str = "Reloading";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target=T>> OrgFreedesktopSystemd1Manager for nonblock::Proxy<'a, C> {

    fn get_unit(&self, name: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetUnit", (name, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn get_unit_by_pid(&self, pid: u32) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetUnitByPID", (pid, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn get_unit_by_invocation_id(&self, invocation_id: Vec<u8>) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetUnitByInvocationID", (invocation_id, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn get_unit_by_control_group(&self, cgroup: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetUnitByControlGroup", (cgroup, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn load_unit(&self, name: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "LoadUnit", (name, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn start_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "StartUnit", (name, mode, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn start_unit_with_flags(&self, name: &str, mode: &str, flags: u64) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "StartUnitWithFlags", (name, mode, flags, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn start_unit_replace(&self, old_unit: &str, new_unit: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "StartUnitReplace", (old_unit, new_unit, mode, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn stop_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "StopUnit", (name, mode, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn reload_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ReloadUnit", (name, mode, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn restart_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "RestartUnit", (name, mode, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn try_restart_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "TryRestartUnit", (name, mode, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn reload_or_restart_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ReloadOrRestartUnit", (name, mode, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn reload_or_try_restart_unit(&self, name: &str, mode: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ReloadOrTryRestartUnit", (name, mode, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn enqueue_unit_job(&self, name: &str, job_type: &str, job_mode: &str) -> nonblock::MethodReply<(u32, dbus::Path<'static>, String, dbus::Path<'static>, String, Vec<(u32, dbus::Path<'static>, String, dbus::Path<'static>, String)>)> {
        self.method_call("org.freedesktop.systemd1.Manager", "EnqueueUnitJob", (name, job_type, job_mode, ))
    }

    fn kill_unit(&self, name: &str, whom: &str, signal: i32) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "KillUnit", (name, whom, signal, ))
    }

    fn clean_unit(&self, name: &str, mask: Vec<&str>) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "CleanUnit", (name, mask, ))
    }

    fn freeze_unit(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "FreezeUnit", (name, ))
    }

    fn thaw_unit(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "ThawUnit", (name, ))
    }

    fn reset_failed_unit(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "ResetFailedUnit", (name, ))
    }

    fn set_unit_properties(&self, name: &str, runtime: bool, properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "SetUnitProperties", (name, runtime, properties, ))
    }

    fn bind_mount_unit(&self, name: &str, source: &str, destination: &str, read_only: bool, mkdir: bool) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "BindMountUnit", (name, source, destination, read_only, mkdir, ))
    }

    fn mount_image_unit(&self, name: &str, source: &str, destination: &str, read_only: bool, mkdir: bool, options: Vec<(&str, &str)>) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "MountImageUnit", (name, source, destination, read_only, mkdir, options, ))
    }

    fn ref_unit(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "RefUnit", (name, ))
    }

    fn unref_unit(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "UnrefUnit", (name, ))
    }

    fn start_transient_unit(&self, name: &str, mode: &str, properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>, aux: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)>) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "StartTransientUnit", (name, mode, properties, aux, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn get_unit_processes(&self, name: &str) -> nonblock::MethodReply<Vec<(String, u32, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetUnitProcesses", (name, ))
            .and_then(|r: (Vec<(String, u32, String)>, )| Ok(r.0, ))
    }

    fn attach_processes_to_unit(&self, unit_name: &str, subcgroup: &str, pids: Vec<u32>) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "AttachProcessesToUnit", (unit_name, subcgroup, pids, ))
    }

    fn abandon_scope(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "AbandonScope", (name, ))
    }

    fn get_job(&self, id: u32) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetJob", (id, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn get_job_after(&self, id: u32) -> nonblock::MethodReply<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetJobAfter", (id, ))
            .and_then(|r: (Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, )| Ok(r.0, ))
    }

    fn get_job_before(&self, id: u32) -> nonblock::MethodReply<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetJobBefore", (id, ))
            .and_then(|r: (Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, )| Ok(r.0, ))
    }

    fn cancel_job(&self, id: u32) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "CancelJob", (id, ))
    }

    fn clear_jobs(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "ClearJobs", ())
    }

    fn reset_failed(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "ResetFailed", ())
    }

    fn set_show_status_(&self, mode: &str) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "SetShowStatus", (mode, ))
    }

    fn list_units(&self) -> nonblock::MethodReply<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ListUnits", ())
            .and_then(|r: (Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, )| Ok(r.0, ))
    }

    fn list_units_filtered(&self, states: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ListUnitsFiltered", (states, ))
            .and_then(|r: (Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, )| Ok(r.0, ))
    }

    fn list_units_by_patterns(&self, states: Vec<&str>, patterns: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ListUnitsByPatterns", (states, patterns, ))
            .and_then(|r: (Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, )| Ok(r.0, ))
    }

    fn list_units_by_names(&self, names: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ListUnitsByNames", (names, ))
            .and_then(|r: (Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, )| Ok(r.0, ))
    }

    fn list_jobs(&self) -> nonblock::MethodReply<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ListJobs", ())
            .and_then(|r: (Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, )| Ok(r.0, ))
    }

    fn subscribe(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "Subscribe", ())
    }

    fn unsubscribe(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "Unsubscribe", ())
    }

    fn dump(&self) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.systemd1.Manager", "Dump", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }

    fn dump_by_file_descriptor(&self) -> nonblock::MethodReply<arg::OwnedFd> {
        self.method_call("org.freedesktop.systemd1.Manager", "DumpByFileDescriptor", ())
            .and_then(|r: (arg::OwnedFd, )| Ok(r.0, ))
    }

    fn reload(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "Reload", ())
    }

    fn reexecute(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "Reexecute", ())
    }

    fn exit(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "Exit", ())
    }

    fn reboot(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "Reboot", ())
    }

    fn power_off(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "PowerOff", ())
    }

    fn halt(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "Halt", ())
    }

    fn kexec(&self) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "KExec", ())
    }

    fn switch_root(&self, new_root: &str, init: &str) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "SwitchRoot", (new_root, init, ))
    }

    fn set_environment_(&self, assignments: Vec<&str>) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "SetEnvironment", (assignments, ))
    }

    fn unset_environment(&self, names: Vec<&str>) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "UnsetEnvironment", (names, ))
    }

    fn unset_and_set_environment(&self, names: Vec<&str>, assignments: Vec<&str>) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "UnsetAndSetEnvironment", (names, assignments, ))
    }

    fn enqueue_marked_jobs(&self) -> nonblock::MethodReply<Vec<dbus::Path<'static>>> {
        self.method_call("org.freedesktop.systemd1.Manager", "EnqueueMarkedJobs", ())
            .and_then(|r: (Vec<dbus::Path<'static>>, )| Ok(r.0, ))
    }

    fn list_unit_files(&self) -> nonblock::MethodReply<Vec<(String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ListUnitFiles", ())
            .and_then(|r: (Vec<(String, String)>, )| Ok(r.0, ))
    }

    fn list_unit_files_by_patterns(&self, states: Vec<&str>, patterns: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "ListUnitFilesByPatterns", (states, patterns, ))
            .and_then(|r: (Vec<(String, String)>, )| Ok(r.0, ))
    }

    fn get_unit_file_state(&self, file: &str) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetUnitFileState", (file, ))
            .and_then(|r: (String, )| Ok(r.0, ))
    }

    fn enable_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)> {
        self.method_call("org.freedesktop.systemd1.Manager", "EnableUnitFiles", (files, runtime, force, ))
    }

    fn disable_unit_files(&self, files: Vec<&str>, runtime: bool) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "DisableUnitFiles", (files, runtime, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn enable_unit_files_with_flags(&self, files: Vec<&str>, flags: u64) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)> {
        self.method_call("org.freedesktop.systemd1.Manager", "EnableUnitFilesWithFlags", (files, flags, ))
    }

    fn disable_unit_files_with_flags(&self, files: Vec<&str>, flags: u64) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "DisableUnitFilesWithFlags", (files, flags, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn reenable_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)> {
        self.method_call("org.freedesktop.systemd1.Manager", "ReenableUnitFiles", (files, runtime, force, ))
    }

    fn link_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "LinkUnitFiles", (files, runtime, force, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn preset_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)> {
        self.method_call("org.freedesktop.systemd1.Manager", "PresetUnitFiles", (files, runtime, force, ))
    }

    fn preset_unit_files_with_mode(&self, files: Vec<&str>, mode: &str, runtime: bool, force: bool) -> nonblock::MethodReply<(bool, Vec<(String, String, String)>)> {
        self.method_call("org.freedesktop.systemd1.Manager", "PresetUnitFilesWithMode", (files, mode, runtime, force, ))
    }

    fn mask_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "MaskUnitFiles", (files, runtime, force, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn unmask_unit_files(&self, files: Vec<&str>, runtime: bool) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "UnmaskUnitFiles", (files, runtime, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn revert_unit_files(&self, files: Vec<&str>) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "RevertUnitFiles", (files, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn set_default_target(&self, name: &str, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "SetDefaultTarget", (name, force, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn get_default_target(&self) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetDefaultTarget", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }

    fn preset_all_unit_files(&self, mode: &str, runtime: bool, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "PresetAllUnitFiles", (mode, runtime, force, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn add_dependency_unit_files(&self, files: Vec<&str>, target: &str, type_: &str, runtime: bool, force: bool) -> nonblock::MethodReply<Vec<(String, String, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "AddDependencyUnitFiles", (files, target, type_, runtime, force, ))
            .and_then(|r: (Vec<(String, String, String)>, )| Ok(r.0, ))
    }

    fn get_unit_file_links(&self, name: &str, runtime: bool) -> nonblock::MethodReply<Vec<String>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetUnitFileLinks", (name, runtime, ))
            .and_then(|r: (Vec<String>, )| Ok(r.0, ))
    }

    fn set_exit_code_(&self, number: u8) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.systemd1.Manager", "SetExitCode", (number, ))
    }

    fn lookup_dynamic_user_by_name(&self, name: &str) -> nonblock::MethodReply<u32> {
        self.method_call("org.freedesktop.systemd1.Manager", "LookupDynamicUserByName", (name, ))
            .and_then(|r: (u32, )| Ok(r.0, ))
    }

    fn lookup_dynamic_user_by_uid(&self, uid: u32) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.systemd1.Manager", "LookupDynamicUserByUID", (uid, ))
            .and_then(|r: (String, )| Ok(r.0, ))
    }

    fn get_dynamic_users(&self) -> nonblock::MethodReply<Vec<(u32, String)>> {
        self.method_call("org.freedesktop.systemd1.Manager", "GetDynamicUsers", ())
            .and_then(|r: (Vec<(u32, String)>, )| Ok(r.0, ))
    }

    fn version(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Version")
    }

    fn features(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Features")
    }

    fn virtualization(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Virtualization")
    }

    fn architecture(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Architecture")
    }

    fn tainted(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Tainted")
    }

    fn firmware_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "FirmwareTimestamp")
    }

    fn firmware_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "FirmwareTimestampMonotonic")
    }

    fn loader_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "LoaderTimestamp")
    }

    fn loader_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "LoaderTimestampMonotonic")
    }

    fn kernel_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "KernelTimestamp")
    }

    fn kernel_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "KernelTimestampMonotonic")
    }

    fn init_rdtimestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDTimestamp")
    }

    fn init_rdtimestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDTimestampMonotonic")
    }

    fn userspace_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UserspaceTimestamp")
    }

    fn userspace_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UserspaceTimestampMonotonic")
    }

    fn finish_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "FinishTimestamp")
    }

    fn finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "FinishTimestampMonotonic")
    }

    fn security_start_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SecurityStartTimestamp")
    }

    fn security_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SecurityStartTimestampMonotonic")
    }

    fn security_finish_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SecurityFinishTimestamp")
    }

    fn security_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SecurityFinishTimestampMonotonic")
    }

    fn generators_start_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "GeneratorsStartTimestamp")
    }

    fn generators_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "GeneratorsStartTimestampMonotonic")
    }

    fn generators_finish_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "GeneratorsFinishTimestamp")
    }

    fn generators_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "GeneratorsFinishTimestampMonotonic")
    }

    fn units_load_start_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadStartTimestamp")
    }

    fn units_load_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadStartTimestampMonotonic")
    }

    fn units_load_finish_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadFinishTimestamp")
    }

    fn units_load_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadFinishTimestampMonotonic")
    }

    fn units_load_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadTimestamp")
    }

    fn units_load_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitsLoadTimestampMonotonic")
    }

    fn init_rdsecurity_start_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDSecurityStartTimestamp")
    }

    fn init_rdsecurity_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDSecurityStartTimestampMonotonic")
    }

    fn init_rdsecurity_finish_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDSecurityFinishTimestamp")
    }

    fn init_rdsecurity_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDSecurityFinishTimestampMonotonic")
    }

    fn init_rdgenerators_start_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDGeneratorsStartTimestamp")
    }

    fn init_rdgenerators_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDGeneratorsStartTimestampMonotonic")
    }

    fn init_rdgenerators_finish_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDGeneratorsFinishTimestamp")
    }

    fn init_rdgenerators_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDGeneratorsFinishTimestampMonotonic")
    }

    fn init_rdunits_load_start_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDUnitsLoadStartTimestamp")
    }

    fn init_rdunits_load_start_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDUnitsLoadStartTimestampMonotonic")
    }

    fn init_rdunits_load_finish_timestamp(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDUnitsLoadFinishTimestamp")
    }

    fn init_rdunits_load_finish_timestamp_monotonic(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "InitRDUnitsLoadFinishTimestampMonotonic")
    }

    fn log_level(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "LogLevel")
    }

    fn log_target(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "LogTarget")
    }

    fn nnames(&self) -> nonblock::MethodReply<u32> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NNames")
    }

    fn nfailed_units(&self) -> nonblock::MethodReply<u32> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NFailedUnits")
    }

    fn njobs(&self) -> nonblock::MethodReply<u32> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NJobs")
    }

    fn ninstalled_jobs(&self) -> nonblock::MethodReply<u32> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NInstalledJobs")
    }

    fn nfailed_jobs(&self) -> nonblock::MethodReply<u32> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "NFailedJobs")
    }

    fn progress(&self) -> nonblock::MethodReply<f64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Progress")
    }

    fn environment(&self) -> nonblock::MethodReply<Vec<String>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "Environment")
    }

    fn confirm_spawn(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ConfirmSpawn")
    }

    fn show_status(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ShowStatus")
    }

    fn unit_path(&self) -> nonblock::MethodReply<Vec<String>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "UnitPath")
    }

    fn default_standard_output(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultStandardOutput")
    }

    fn default_standard_error(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultStandardError")
    }

    fn runtime_watchdog_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "RuntimeWatchdogUSec")
    }

    fn runtime_watchdog_pre_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "RuntimeWatchdogPreUSec")
    }

    fn runtime_watchdog_pre_governor(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "RuntimeWatchdogPreGovernor")
    }

    fn reboot_watchdog_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "RebootWatchdogUSec")
    }

    fn kexec_watchdog_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "KExecWatchdogUSec")
    }

    fn service_watchdogs(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ServiceWatchdogs")
    }

    fn control_group(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ControlGroup")
    }

    fn system_state(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "SystemState")
    }

    fn exit_code(&self) -> nonblock::MethodReply<u8> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "ExitCode")
    }

    fn default_timer_accuracy_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTimerAccuracyUSec")
    }

    fn default_timeout_start_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTimeoutStartUSec")
    }

    fn default_timeout_stop_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTimeoutStopUSec")
    }

    fn default_timeout_abort_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTimeoutAbortUSec")
    }

    fn default_restart_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultRestartUSec")
    }

    fn default_start_limit_interval_usec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultStartLimitIntervalUSec")
    }

    fn default_start_limit_burst(&self) -> nonblock::MethodReply<u32> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultStartLimitBurst")
    }

    fn default_cpuaccounting(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultCPUAccounting")
    }

    fn default_block_ioaccounting(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultBlockIOAccounting")
    }

    fn default_memory_accounting(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultMemoryAccounting")
    }

    fn default_tasks_accounting(&self) -> nonblock::MethodReply<bool> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTasksAccounting")
    }

    fn default_limit_cpu(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitCPU")
    }

    fn default_limit_cpusoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitCPUSoft")
    }

    fn default_limit_fsize(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitFSIZE")
    }

    fn default_limit_fsizesoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitFSIZESoft")
    }

    fn default_limit_data(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitDATA")
    }

    fn default_limit_datasoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitDATASoft")
    }

    fn default_limit_stack(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitSTACK")
    }

    fn default_limit_stacksoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitSTACKSoft")
    }

    fn default_limit_core(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitCORE")
    }

    fn default_limit_coresoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitCORESoft")
    }

    fn default_limit_rss(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRSS")
    }

    fn default_limit_rsssoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRSSSoft")
    }

    fn default_limit_nofile(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNOFILE")
    }

    fn default_limit_nofilesoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNOFILESoft")
    }

    fn default_limit_as(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitAS")
    }

    fn default_limit_assoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitASSoft")
    }

    fn default_limit_nproc(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNPROC")
    }

    fn default_limit_nprocsoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNPROCSoft")
    }

    fn default_limit_memlock(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitMEMLOCK")
    }

    fn default_limit_memlocksoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitMEMLOCKSoft")
    }

    fn default_limit_locks(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitLOCKS")
    }

    fn default_limit_lockssoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitLOCKSSoft")
    }

    fn default_limit_sigpending(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitSIGPENDING")
    }

    fn default_limit_sigpendingsoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitSIGPENDINGSoft")
    }

    fn default_limit_msgqueue(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitMSGQUEUE")
    }

    fn default_limit_msgqueuesoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitMSGQUEUESoft")
    }

    fn default_limit_nice(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNICE")
    }

    fn default_limit_nicesoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitNICESoft")
    }

    fn default_limit_rtprio(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRTPRIO")
    }

    fn default_limit_rtpriosoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRTPRIOSoft")
    }

    fn default_limit_rttime(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRTTIME")
    }

    fn default_limit_rttimesoft(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultLimitRTTIMESoft")
    }

    fn default_tasks_max(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultTasksMax")
    }

    fn timer_slack_nsec(&self) -> nonblock::MethodReply<u64> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "TimerSlackNSec")
    }

    fn default_oompolicy(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultOOMPolicy")
    }

    fn default_oomscore_adjust(&self) -> nonblock::MethodReply<i32> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "DefaultOOMScoreAdjust")
    }

    fn ctrl_alt_del_burst_action(&self) -> nonblock::MethodReply<String> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.systemd1.Manager", "CtrlAltDelBurstAction")
    }

    fn set_log_level(&self, value: String) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "LogLevel", value)
    }

    fn set_log_target(&self, value: String) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "LogTarget", value)
    }

    fn set_runtime_watchdog_usec(&self, value: u64) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "RuntimeWatchdogUSec", value)
    }

    fn set_runtime_watchdog_pre_usec(&self, value: u64) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "RuntimeWatchdogPreUSec", value)
    }

    fn set_runtime_watchdog_pre_governor(&self, value: String) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "RuntimeWatchdogPreGovernor", value)
    }

    fn set_reboot_watchdog_usec(&self, value: u64) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "RebootWatchdogUSec", value)
    }

    fn set_kexec_watchdog_usec(&self, value: u64) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "KExecWatchdogUSec", value)
    }

    fn set_service_watchdogs(&self, value: bool) -> nonblock::MethodReply<()> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.systemd1.Manager", "ServiceWatchdogs", value)
    }
}
